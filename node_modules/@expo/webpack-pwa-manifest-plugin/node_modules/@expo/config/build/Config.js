"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const json_file_1 = __importDefault(require("@expo/json-file"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const path_1 = __importDefault(require("path"));
const slugify_1 = __importDefault(require("slugify"));
const Errors_1 = require("./Errors");
const Project_1 = require("./Project");
function readConfigJson(projectRoot, skipValidation = false, skipNativeValidation = false) {
    const { configPath } = findConfigFile(projectRoot);
    let rawConfig = null;
    try {
        rawConfig = json_file_1.default.read(configPath, { json5: true });
    }
    catch (_) { }
    const { rootConfig, exp } = parseAndValidateRootConfig(rawConfig, skipValidation);
    const packageJsonPath = getRootPackageJsonPath(projectRoot, exp);
    const pkg = json_file_1.default.read(packageJsonPath);
    return Object.assign(Object.assign({}, ensureConfigHasDefaultValues(projectRoot, exp, pkg, skipNativeValidation)), { rootConfig: rootConfig });
}
exports.readConfigJson = readConfigJson;
function readConfigJsonAsync(projectRoot, skipValidation = false, skipNativeValidation = false) {
    return __awaiter(this, void 0, void 0, function* () {
        const { configPath } = findConfigFile(projectRoot);
        let rawConfig = null;
        try {
            rawConfig = yield json_file_1.default.readAsync(configPath, { json5: true });
        }
        catch (_) { }
        const { rootConfig, exp } = parseAndValidateRootConfig(rawConfig, skipValidation);
        const packageJsonPath = getRootPackageJsonPath(projectRoot, exp);
        const pkg = yield json_file_1.default.readAsync(packageJsonPath);
        return Object.assign(Object.assign({}, ensureConfigHasDefaultValues(projectRoot, exp, pkg, skipNativeValidation)), { rootConfig: rootConfig });
    });
}
exports.readConfigJsonAsync = readConfigJsonAsync;
function findConfigFile(projectRoot) {
    const APP_JSON_FILE_NAME = 'app.json';
    let configPath;
    if (customConfigPaths[projectRoot]) {
        configPath = customConfigPaths[projectRoot];
    }
    else {
        configPath = path_1.default.join(projectRoot, APP_JSON_FILE_NAME);
    }
    return { configPath, configName: APP_JSON_FILE_NAME, configNamespace: 'expo' };
}
exports.findConfigFile = findConfigFile;
function configFilename(projectRoot) {
    return findConfigFile(projectRoot).configName;
}
exports.configFilename = configFilename;
function readExpRcAsync(projectRoot) {
    return __awaiter(this, void 0, void 0, function* () {
        const expRcPath = path_1.default.join(projectRoot, '.exprc');
        return yield json_file_1.default.readAsync(expRcPath, { json5: true, cantReadFileDefault: {} });
    });
}
exports.readExpRcAsync = readExpRcAsync;
const customConfigPaths = {};
function setCustomConfigPath(projectRoot, configPath) {
    customConfigPaths[projectRoot] = configPath;
}
exports.setCustomConfigPath = setCustomConfigPath;
const APP_JSON_EXAMPLE = JSON.stringify({
    expo: {
        name: 'My app',
        slug: 'my-app',
        sdkVersion: '...',
    },
});
function parseAndValidateRootConfig(rootConfig, skipValidation) {
    let outputRootConfig = rootConfig;
    if (outputRootConfig === null || typeof outputRootConfig !== 'object') {
        if (skipValidation) {
            outputRootConfig = { expo: {} };
        }
        else {
            throw new Errors_1.ConfigError('app.json must include a JSON object.', 'NOT_OBJECT');
        }
    }
    const exp = outputRootConfig.expo;
    if (exp === null || typeof exp !== 'object') {
        throw new Errors_1.ConfigError(`Property 'expo' in app.json is not an object. Please make sure app.json includes a managed Expo app config like this: ${APP_JSON_EXAMPLE}`, 'NO_EXPO');
    }
    return {
        exp,
        rootConfig: outputRootConfig,
    };
}
function getRootPackageJsonPath(projectRoot, exp) {
    const packageJsonPath = 'nodeModulesPath' in exp && typeof exp.nodeModulesPath === 'string'
        ? path_1.default.join(path_1.default.resolve(projectRoot, exp.nodeModulesPath), 'package.json')
        : path_1.default.join(projectRoot, 'package.json');
    if (!fs_extra_1.default.existsSync(packageJsonPath)) {
        throw new Errors_1.ConfigError(`The expected package.json path: ${packageJsonPath} does not exist`, 'MODULE_NOT_FOUND');
    }
    return packageJsonPath;
}
function ensureConfigHasDefaultValues(projectRoot, exp, pkg, skipNativeValidation = false) {
    if (!exp)
        exp = {};
    if (!exp.name && typeof pkg.name === 'string') {
        exp.name = pkg.name;
    }
    if (!exp.description && typeof pkg.description === 'string') {
        exp.description = pkg.description;
    }
    if (!exp.slug && typeof exp.name === 'string') {
        exp.slug = slugify_1.default(exp.name.toLowerCase());
    }
    if (!exp.version && typeof pkg.version === 'string') {
        exp.version = pkg.version;
    }
    if (exp.nodeModulesPath) {
        exp.nodeModulesPath = path_1.default.resolve(projectRoot, exp.nodeModulesPath);
    }
    try {
        exp.sdkVersion = Project_1.getExpoSDKVersion(projectRoot, exp);
    }
    catch (error) {
        if (!skipNativeValidation)
            throw error;
    }
    if (!exp.platforms) {
        exp.platforms = ['android', 'ios'];
    }
    return { exp, pkg };
}
function writeConfigJsonAsync(projectRoot, options) {
    return __awaiter(this, void 0, void 0, function* () {
        const { configPath } = findConfigFile(projectRoot);
        let { exp, pkg, rootConfig } = yield readConfigJsonAsync(projectRoot);
        exp = Object.assign(Object.assign({}, exp), options);
        rootConfig = Object.assign(Object.assign({}, rootConfig), { expo: exp });
        yield json_file_1.default.writeAsync(configPath, rootConfig, { json5: false });
        return {
            exp,
            pkg,
            rootConfig,
        };
    });
}
exports.writeConfigJsonAsync = writeConfigJsonAsync;
//# sourceMappingURL=Config.js.map