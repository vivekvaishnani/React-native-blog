"use strict";
/* eslint-env node */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const config_1 = require("@expo/config");
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const url_1 = __importDefault(require("url"));
const paths_1 = require("@expo/config/paths");
const getMode_1 = __importDefault(require("./getMode"));
function parsePaths(projectRoot, nativeAppManifest) {
    const inputProjectRoot = projectRoot || paths_1.getPossibleProjectRoot();
    function absolute(...pathComponents) {
        return paths_1.getAbsolutePathWithProjectRoot(inputProjectRoot, ...pathComponents);
    }
    const packageJsonPath = absolute('package.json');
    const modulesPath = paths_1.getModulesPath(inputProjectRoot);
    const productionPath = absolute(config_1.getWebOutputPath(nativeAppManifest));
    function templatePath(filename = '') {
        const overridePath = absolute('web', filename);
        if (fs_1.default.existsSync(overridePath)) {
            return overridePath;
        }
        return path_1.default.join(__dirname, '../../web-default', filename);
    }
    function getProductionPath(...props) {
        return path_1.default.resolve(productionPath, ...props);
    }
    function getIncludeModule(...props) {
        return path_1.default.resolve(modulesPath, ...props);
    }
    return {
        absolute,
        includeModule: getIncludeModule,
        packageJson: packageJsonPath,
        root: path_1.default.resolve(inputProjectRoot),
        appMain: paths_1.getEntryPoint(inputProjectRoot, ['./index', './src/index'], ['web']),
        modules: modulesPath,
        servedPath: getServedPath(inputProjectRoot),
        template: {
            get: templatePath,
            folder: templatePath(),
            indexHtml: templatePath('index.html'),
            manifest: templatePath('manifest.json'),
            serveJson: templatePath('serve.json'),
            favicon: templatePath('favicon.ico'),
            serviceWorker: templatePath('expo-service-worker.js'),
            registerServiceWorker: templatePath('register-service-worker.js'),
        },
        production: {
            get: getProductionPath,
            folder: getProductionPath(),
            indexHtml: getProductionPath('index.html'),
            manifest: getProductionPath('manifest.json'),
            serveJson: getProductionPath('serve.json'),
            favicon: getProductionPath('favicon.ico'),
            serviceWorker: getProductionPath('expo-service-worker.js'),
            registerServiceWorker: getProductionPath('register-service-worker.js'),
        },
    };
}
function getPaths(projectRoot) {
    const { exp } = config_1.readConfigJson(projectRoot, true, true);
    return parsePaths(projectRoot, exp);
}
exports.getPaths = getPaths;
function getPathsAsync(projectRoot) {
    return __awaiter(this, void 0, void 0, function* () {
        let exp;
        try {
            exp = (yield config_1.readConfigJsonAsync(projectRoot, true, true)).exp;
        }
        catch (error) { }
        return parsePaths(projectRoot, exp);
    });
}
exports.getPathsAsync = getPathsAsync;
function getServedPath(projectRoot) {
    const { pkg } = config_1.readConfigJson(projectRoot, true, true);
    const envPublicUrl = process.env.WEB_PUBLIC_URL;
    // We use `WEB_PUBLIC_URL` environment variable or "homepage" field to infer
    // "public path" at which the app is served.
    // Webpack needs to know it to put the right <script> hrefs into HTML even in
    // single-page apps that may serve index.html for nested URLs like /todos/42.
    // We can't use a relative path in HTML because we don't want to load something
    // like /todos/42/static/js/bundle.7289d.js. We have to know the root.
    const publicUrl = envPublicUrl || pkg.homepage;
    const servedUrl = envPublicUrl || (publicUrl ? url_1.default.parse(publicUrl).pathname : '/');
    return paths_1.ensureSlash(servedUrl, true);
}
exports.getServedPath = getServedPath;
function getPublicPaths(_a) {
    var { projectRoot } = _a, env = __rest(_a, ["projectRoot"]);
    if (getMode_1.default(env) === 'production') {
        const publicPath = getServedPath(projectRoot);
        return {
            publicPath,
            publicUrl: publicPath.slice(0, -1),
        };
    }
    return { publicUrl: '', publicPath: '/' };
}
exports.getPublicPaths = getPublicPaths;
function getProductionPath(projectRoot) {
    const { exp } = config_1.readConfigJson(projectRoot, true, true);
    return paths_1.getAbsolutePathWithProjectRoot(projectRoot, config_1.getWebOutputPath(exp));
}
exports.getProductionPath = getProductionPath;
/**
 * get absolute path relative to project root while accounting for `https://` paths
 */
function getAbsolute(projectRoot, ...pathComponents) {
    const inputProjectRoot = projectRoot || paths_1.getPossibleProjectRoot();
    return paths_1.getAbsolutePathWithProjectRoot(inputProjectRoot, ...pathComponents);
}
exports.getAbsolute = getAbsolute;
//# sourceMappingURL=paths.js.map