import os from 'os';
import path from 'path';

import bunyan from 'bunyan';
import uuidv4 from 'uuid/v4';

import spawn from '../../../utils/spawn';
import fastlane from './fastlane';

class Keychain {
  private logger: bunyan;
  private keychainPath: string;
  private keychainPassword: string;
  private created: boolean = false;

  constructor(logger: bunyan) {
    this.logger = logger;
    this.keychainPath = path.join(os.tmpdir(), `turtle-v2-${uuidv4()}.keychain`);
    this.keychainPassword = uuidv4();
  }

  get data() {
    return {
      path: this.keychainPath,
      password: this.keychainPassword,
    };
  }

  public async create() {
    this.logger.debug(`Creating keychain - ${this.keychainPath}`);
    await fastlane([
      'run',
      'create_keychain',
      `path:${this.keychainPath}`,
      `password:${this.keychainPassword}`,
      'unlock:true',
      'timeout:360000',
    ]);
    this.created = true;
  }

  public async importCertificate(certPath: string, certPassword: string) {
    if (!this.created) {
      throw new Error('You must create a keychain first.');
    }

    this.logger.debug(`Importing certificate ${certPath} into keychain ${this.keychainPath}`);
    await fastlane([
      'run',
      'import_certificate',
      `certificate_path:${certPath}`,
      `certificate_password:${certPassword}`,
      `keychain_path:${this.keychainPath}`,
      `keychain_password:${this.keychainPassword}`,
    ]);
  }

  public async ensureCertificateImported(teamId: string, fingerprint: string) {
    const identities = await this.findIdentitiesByTeamId(teamId);
    const isValid = identities.indexOf(fingerprint) !== -1;
    if (!isValid) {
      throw new Error(`Distribution certificate with fingerprint ${fingerprint} hasn't been imported successfully`);
    }
  }

  public async destroy(keychainPath?: string) {
    if (!keychainPath && !this.created) {
      this.logger.warn('There is nothing to destroy, a keychain hasn\'t been created yet.');
      return;
    }
    const keychainToDeletePath = keychainPath || this.keychainPath;
    this.logger.info(`Destroying keychain - ${keychainToDeletePath}`);
    await fastlane([
      'run',
      'delete_keychain',
      `keychain_path:${keychainToDeletePath}`,
    ]);
  }

  public async cleanUpKeychains() {
    const { stdout } = await spawn('security', ['list-keychains'], { stdio: 'pipe' });
    const keychainList = (stdout.match(/"(.*)"/g) || []).map((i) =>
      i.slice(1, i.length - 1),
    );
    const turtleKeychainList = keychainList.filter((keychain) => keychain.match(/turtle-v2-[\w-]+\.keychain$/));
    for (const turtleKeychainPath of turtleKeychainList) {
      await this.destroy(turtleKeychainPath);
    }
  }

  private async findIdentitiesByTeamId(teamId: string) {
    const { output } = await spawn(
      'security',
      ['find-identity', '-v', '-s', `(${teamId})`, this.keychainPath],
      { stdio: 'pipe' },
    );
    return output.join('');
  }
}

export default Keychain;
