import crypto from 'crypto';
import os from 'os';
import path from 'path';

import bunyan from 'bunyan';
import fs from 'fs-extra';
import isError from 'lodash/isError';
import plist from 'plist';
import uuid from 'uuid/v4';

import spawn from '../../../utils/spawn';

interface ProvisioningProfileData {
  bundleIdentifier: string;
  teamId: string;
  uuid: string;
  developerCertificate: Buffer;
}

const PROVISIONING_PROFILES_DIRECTORY = path.join(
  os.homedir(),
  'Library/MobileDevice/Provisioning Profiles',
);

class ProvisioningProfile {
  get data() {
    if (!this.profileData) {
      throw new Error('You must init the profile first!');
    } else {
      return this.profileData!;
    }
  }
  private logger: bunyan;
  private profile: Buffer;
  private profilePath: string;
  private profileData?: ProvisioningProfileData;

  constructor(logger: bunyan, profile: Buffer) {
    this.logger = logger;
    this.profile = profile;
    this.profilePath = path.join(PROVISIONING_PROFILES_DIRECTORY, `${uuid()}.mobileprovision`);
  }

  public async init() {
    this.logger.debug(`Making sure ${PROVISIONING_PROFILES_DIRECTORY} exits`);
    await fs.ensureDir(PROVISIONING_PROFILES_DIRECTORY);

    this.logger.debug(`Writing provisioning profile to ${this.profilePath}`);
    await fs.writeFile(this.profilePath, this.profile);

    this.logger.debug('Loading provisioning profile');
    await this.load();
  }

  public async destroy() {
    if (!this.profilePath) {
      this.logger.warn('There is nothing to destroy, a provisioning profile hasn\'t been created yet.');
      return;

    }
    this.logger.info('Removing provisioning profile');
    await fs.remove(this.profilePath);
  }

  public async verifyCertificate(fingerprint: string) {
    const devCertFingerprint = this.genDerCertFingerprint(this.data.developerCertificate);
    if (devCertFingerprint !== fingerprint) {
      throw new Error(
        `Provisioning profile and distribution certificate don't match.
Profile's certificate fingerprint = ${devCertFingerprint}, distribution certificate fingerprint = ${fingerprint}`,
      );
    }
  }

  private async load() {
    let result;
    try {
      result = await spawn(
        'security',
        ['cms', '-D', '-i', this.profilePath],
        { stdio: 'pipe' },
      );
    } catch (err) {
      throw new Error(err.stderr.trim());
    }
    const { output } = result!;

    const plistRaw = output.join('');
    const plistData = plist.parse(plistRaw) as plist.PlistObject;
    if (isError(plistData)) {
      throw new Error(`Error when parsing plist: ${plistData.message}`);
    }

    const applicationIdentifier = (plistData.Entitlements as plist.PlistObject)['application-identifier'] as string;
    const bundleIdentifier = applicationIdentifier.replace(/^.+?\./, '');

    this.profileData = {
      bundleIdentifier,
      teamId: (plistData.TeamIdentifier as string[])[0] as string,
      uuid: plistData.UUID as string,
      developerCertificate: Buffer.from((plistData.DeveloperCertificates as string[])[0] as string, 'base64'),
    };
  }

  private genDerCertFingerprint(cert: Buffer) {
    return crypto
      .createHash('sha1')
      .update(cert)
      .digest('hex')
      .toUpperCase();
  }
}

export default ProvisioningProfile;
