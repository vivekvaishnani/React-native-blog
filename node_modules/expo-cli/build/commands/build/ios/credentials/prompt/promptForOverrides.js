"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _xdl() {
  const data = require("@expo/xdl");

  _xdl = function () {
    return data;
  };

  return data;
}

function _ora() {
  const data = _interopRequireDefault(require("ora"));

  _ora = function () {
    return data;
  };

  return data;
}

function _isObject() {
  const data = _interopRequireDefault(require("lodash/isObject"));

  _isObject = function () {
    return data;
  };

  return data;
}

function constants() {
  const data = _interopRequireWildcard(require("../constants"));

  constants = function () {
    return data;
  };

  return data;
}

function _promptForCredentials() {
  const data = _interopRequireDefault(require("./promptForCredentials"));

  _promptForCredentials = function () {
    return data;
  };

  return data;
}

function _prompt() {
  const data = _interopRequireDefault(require("../../../../../prompt"));

  _prompt = function () {
    return data;
  };

  return data;
}

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const existingCredsGettersByType = {
  distributionCert: _xdl().Credentials.Ios.getExistingDistCerts,
  pushKey: _xdl().Credentials.Ios.getExistingPushKeys
};

async function promptForOverrides(appleCtx, types, projectMetadata) {
  const credentials = {};
  const toAskUserFor = [];

  for (const type of types) {
    const definition = constants().CREDENTIALS[type];
    const {
      dependsOn,
      name,
      canReuse
    } = definition;
    const shouldBeExpoGenerated = dependsOn && !toAskUserFor.includes(dependsOn) && types.includes(dependsOn) && !((0, _isObject().default)(credentials[dependsOn]) && 'reuse' in credentials[dependsOn]);

    if (shouldBeExpoGenerated) {
      // if a user was missing Distribution Certificate
      // and he let Expo handle generating it
      // we must generate new Provisioning Profile
      // (and the user cannot provide his own file)
      credentials[type] = constants().EXPO_WILL_GENERATE;
    } else if (await _willUserProvideCredentialsType(name)) {
      toAskUserFor.push(type);
    } else {
      if (canReuse) {
        const choice = await _askIfWantsToReuse(appleCtx, definition, projectMetadata);

        if (choice) {
          credentials[type] = {
            reuse: choice
          };
        } else {
          credentials[type] = constants().EXPO_WILL_GENERATE;
        }
      } else {
        credentials[type] = constants().EXPO_WILL_GENERATE;
      }
    }
  }

  const userProvidedCredentials = await (0, _promptForCredentials().default)(appleCtx, toAskUserFor, false);
  const credentialsToReturn = { ...credentials,
    ...userProvidedCredentials.credentials
  };
  return {
    credentials: credentialsToReturn,
    metadata: userProvidedCredentials.metadata
  };
}

async function _willUserProvideCredentialsType(name) {
  const {
    answer
  } = await (0, _prompt().default)({
    type: 'list',
    name: 'answer',
    message: `Will you provide your own ${name}?`,
    choices: [{
      name: 'Let Expo handle the process',
      value: false
    }, {
      name: 'I want to upload my own file',
      value: true
    }]
  });
  return answer;
}

async function _askIfWantsToReuse(appleCtx, definition, projectMetadata) {
  const {
    name
  } = definition;
  const existingCreds = await _getExistingCreds(appleCtx, definition, projectMetadata);

  if (!existingCreds) {
    return null;
  }

  const newCertChoice = {
    name: 'No, please create a new one',
    value: null
  };
  const choices = [newCertChoice, ...existingCreds];
  const {
    userChoice
  } = await (0, _prompt().default)({
    type: 'list',
    name: 'userChoice',
    message: `Would you like to reuse ${name} from another app?`,
    choices
  });
  return userChoice;
}

async function _getExistingCreds({
  team: {
    id: appleTeamId
  }
}, {
  id,
  name
}, {
  username
}) {
  const getter = existingCredsGettersByType[id];
  const spinner = (0, _ora().default)(`Looking for ${name} you might have created before...`).start();

  try {
    const existingCreds = await getter(username, appleTeamId);

    if (existingCreds.length === 0) {
      spinner.succeed(`Didn't find any previously uploaded ${name}`);
      return null;
    } else {
      spinner.stop();
      return existingCreds;
    }
  } catch (err) {
    spinner.fail(`Failed when trying to find previously uploaded ${name}`);
    throw err;
  }
}

var _default = promptForOverrides;
exports.default = _default;
//# sourceMappingURL=../../../../../__sourcemaps__/commands/build/ios/credentials/prompt/promptForOverrides.js.map
