"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _untildify() {
  const data = _interopRequireDefault(require("untildify"));

  _untildify = function () {
    return data;
  };

  return data;
}

function _path() {
  const data = _interopRequireDefault(require("path"));

  _path = function () {
    return data;
  };

  return data;
}

function _xdl() {
  const data = require("@expo/xdl");

  _xdl = function () {
    return data;
  };

  return data;
}

function _fsExtra() {
  const data = _interopRequireDefault(require("fs-extra"));

  _fsExtra = function () {
    return data;
  };

  return data;
}

function constants() {
  const data = _interopRequireWildcard(require("../constants"));

  constants = function () {
    return data;
  };

  return data;
}

function _log() {
  const data = _interopRequireDefault(require("../../../../../log"));

  _log = function () {
    return data;
  };

  return data;
}

function _prompt2() {
  const data = _interopRequireDefault(require("../../../../../prompt"));

  _prompt2 = function () {
    return data;
  };

  return data;
}

function validators() {
  const data = _interopRequireWildcard(require("../../../../../validators"));

  validators = function () {
    return data;
  };

  return data;
}

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const EXPERT_PROMPT = `
WARNING! In this mode, we won't be able to make sure your Distribution Certificate,
Push Notifications service key or Provisioning Profile are valid. Please double check
that you're uploading valid files for your app otherwise you may encounter strange errors!

Make sure you've created your app ID on the developer portal, that your app ID
is in app.json as \`bundleIdentifier\`, and that the provisioning profile you
upload matches that team ID and app ID.
`;

async function promptForCredentials(appleCtx, types, printWarning = true) {
  if (printWarning) {
    (0, _log().default)(EXPERT_PROMPT);
  }

  const credentials = {};
  const metadata = {};

  for (const type of types) {
    const value = {};
    const {
      name,
      required,
      questions
    } = constants().CREDENTIALS[type];
    (0, _log().default)(`Please provide your ${name}:`);

    for (const i of required) {
      const question = questions[i];
      const answer = await _askQuestionAndProcessAnswer(question);
      value[i] = answer;
    }

    const valueKeys = Object.keys(value);
    credentials[type] = valueKeys.length === 1 ? value[valueKeys[0]] : value;
    Object.assign(metadata, (await _calculateMetadata(credentials[type])));
  }

  return {
    credentials,
    metadata
  };
}

async function _askQuestionAndProcessAnswer(definition) {
  const questionObject = _buildQuestionObject(definition);

  const {
    input
  } = await (0, _prompt2().default)(questionObject);
  return await _processAnswer(definition, input);
}

function _buildQuestionObject({
  type,
  question
}) {
  const inputType = type === 'password' ? 'password' : 'input';
  const questionObject = {
    type: inputType,
    name: 'input',
    message: question
  };

  if (type === 'file') {
    questionObject.filter = _produceAbsolutePath;
    questionObject.validate = validators().existingFile;
  } else {
    questionObject.validate = validators().nonEmptyInput;
  }

  return questionObject;
}

async function _processAnswer({
  type,
  base64Encode
}, input) {
  if (type === 'file') {
    return _fsExtra().default.readFile(input, base64Encode ? 'base64' : 'utf8');
  } else {
    return input;
  }
}

const _produceAbsolutePath = filePath => {
  const untildified = (0, _untildify().default)(filePath.trim());
  return !_path().default.isAbsolute(untildified) ? _path().default.resolve(untildified) : untildified;
};

async function _calculateMetadata({
  certP12,
  certPassword
}) {
  if (!(certP12 && certPassword)) {
    return null;
  }

  const distCertSerialNumber = _xdl().IosCodeSigning.findP12CertSerialNumber(certP12, certPassword);

  return {
    distCertSerialNumber
  };
}

var _default = promptForCredentials;
exports.default = _default;
//# sourceMappingURL=../../../../../__sourcemaps__/commands/build/ios/credentials/prompt/promptForCredentials.js.map
