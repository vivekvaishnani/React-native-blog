"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.generate = generate;
exports.determineMissingCredentials = determineMissingCredentials;

function _ora() {
  const data = _interopRequireDefault(require("ora"));

  _ora = function () {
    return data;
  };

  return data;
}

function _chalk() {
  const data = _interopRequireDefault(require("chalk"));

  _chalk = function () {
    return data;
  };

  return data;
}

function _intersection() {
  const data = _interopRequireDefault(require("lodash/intersection"));

  _intersection = function () {
    return data;
  };

  return data;
}

function constants() {
  const data = _interopRequireWildcard(require("./constants"));

  constants = function () {
    return data;
  };

  return data;
}

function _log() {
  const data = _interopRequireDefault(require("../../../../log"));

  _log = function () {
    return data;
  };

  return data;
}

function apple() {
  const data = _interopRequireWildcard(require("../../../../appleApi"));

  apple = function () {
    return data;
  };

  return data;
}

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

async function generate(appleCtx, credentialsToGenerate, metadata, projectMetadata) {
  if (!credentialsToGenerate || credentialsToGenerate.length === 0) {
    return {};
  }

  await apple().ensureAppExists(appleCtx, {
    experienceName: projectMetadata.experienceName,
    bundleIdentifier: projectMetadata.bundleIdentifier
  }, {
    enablePushNotifications: true
  });
  (0, _log().default)(`We're going to generate:`);
  credentialsToGenerate.forEach(type => {
    (0, _log().default)(`- ${constants().CREDENTIALS[type].name}`);
  });
  let newCredentials = {};

  for (const id of credentialsToGenerate) {
    const {
      name
    } = constants().CREDENTIALS[id];
    const spinner = (0, _ora().default)(`Generating ${name}...`).start();

    try {
      const generated = await _create(appleCtx, id, metadata, projectMetadata);
      spinner.succeed(`Generated ${name}`);
      newCredentials = { ...newCredentials,
        ...generated
      };
    } catch (err) {
      spinner.fail(`Failed to generate ${name}`);
      throw err;
    }
  }

  return newCredentials;
}

async function _create(appleCtx, type, metadata, projectMetadata) {
  const manager = apple().createManagers(appleCtx)[type];

  if (manager instanceof apple().ProvisioningProfileManager) {
    const {
      bundleIdentifier
    } = projectMetadata;
    return await manager.create(bundleIdentifier, metadata);
  }

  return await manager.create();
}

function determineMissingCredentials(existingCredentials = {}) {
  const existingCredentialsKeys = Object.keys(existingCredentials);
  const missing = constants().REQUIRED_CREDENTIALS.reduce((acc, ruleOrCondition) => {
    const id = _applyRuleOrCondition(existingCredentialsKeys, ruleOrCondition);

    if (id) {
      acc.push(id);
    }

    return acc;
  }, []);
  return missing.length === 0 ? null : missing;
}

function _applyRuleOrCondition(keys, ruleOrCondition) {
  if ('or' in ruleOrCondition) {
    return _applyOrCondition(keys, ruleOrCondition.or);
  } else {
    return _applyRule(keys, ruleOrCondition);
  }
}

function _applyOrCondition(keys, condition) {
  const applyingRules = condition.filter(rule => _doCredentialsExist(keys, rule));

  if (applyingRules.length === 0) {
    const notDeprecatedRule = condition.find(rule => !rule.deprecated);
    return notDeprecatedRule.id;
  } else if (applyingRules.length === 1) {
    const {
      deprecated,
      name,
      migrationDocs
    } = applyingRules[0];

    if (deprecated) {
      _log().default.warn(`You're using deprecated ${name}. Read our docs to learn how to use more modern solution. ${migrationDocs ? _chalk().default.underline(migrationDocs) : ''}`);
    }

    return null;
  }
}

const _applyRule = (keys, rule) => !_doCredentialsExist(keys, rule) ? rule.id : null;

function _doCredentialsExist(keys, rule) {
  const common = (0, _intersection().default)(keys, rule.required);
  return rule.required.length === common.length;
}
//# sourceMappingURL=../../../../__sourcemaps__/commands/build/ios/credentials/generate.js.map
